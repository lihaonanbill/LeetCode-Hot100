# Catalog
1. 215.数组中的第K个最大元素
    - 数组，分治，快速选择，排序，堆(优先队列)
2. 347.前k个高频元素
    - 数组，哈希表，分治，桶排序，计数，快速选择，排序，堆(优先队列)
3. 295.数据流的中位数
    - 设计，双指针，数据流，排序，堆(优先队列)



# 数据结构：堆 (Heap) 详解

## 1. 什么是堆？
堆是一种特殊的完全二叉树（Complete Binary Tree）。根据节点与其子节点的大小关系，堆分为两类：

* **最大堆 (Max Heap)**：任意节点的值都 **大于或等于** 其左右子节点的值。堆顶（根节点）是整个堆中的**最大值**。
* **最小堆 (Min Heap)**：任意节点的值都 **小于或等于** 其左右子节点的值。堆顶（根节点）是整个堆中的**最小值**。



---

## 2. 堆的存储方式
虽然堆是逻辑上的树形结构，但在实际实现中，通常使用**数组**来存储。
由于是完全二叉树，节点在数组中的下标有如下规律（假设根节点下标为 `0`）：

对于下标为 `i` 的节点：
* **左子节点下标**：`2 * i + 1`
* **右子节点下标**：`2 * i + 2`
* **父节点下标**：`(i - 1) // 2`

---

## 3. 核心操作
堆最核心的两个维护动作是 **上浮 (Sift Up)** 和 **下沉 (Sift Down)**。

### 3.1 插入 (Push/Insert)
1. 将新元素添加到数组末尾（保持完全二叉树结构）。
2. **上浮 (Sift Up)**：将该元素与其父节点比较，若破坏了堆序（例如在最大堆中比父节点大），则交换，直到满足堆序或到达根节点。
3. **时间复杂度**：$O(\log n)$

### 3.2 弹出堆顶 (Pop/Delete)
1. 将堆顶元素与数组最后一个元素交换。
2. 移除数组末尾（即原堆顶）。
3. **下沉 (Sift Down)**：将新的堆顶元素与其子节点中较大（或较小）的一个比较，若破坏堆序则交换，直到满足堆序。
4. **时间复杂度**：$O(\log n)$



---

## 4. 堆的应用场景

1.  **优先队列 (Priority Queue)**：如操作系统的任务调度。
2.  **堆排序 (Heap Sort)**：一种不稳定的排序算法，空间复杂度 $O(1)$，时间复杂度 $O(n \log n)$。
3.  **Top K 问题**：寻找一组数中最大或最小的 $K$ 个数（使用小顶堆找前 $K$ 大）。
4.  **合并 K 个有序链表**：利用最小堆维护当前最小元素。

---

## 5. Python 示例 (使用内置 heapq 库)
Python 的 `heapq` 模块默认实现的是**最小堆**。

```python
import heapq

# 1. 创建堆
nums = [3, 1, 4, 1, 5, 9, 2]
heapq.heapify(nums)  # 原地转换为最小堆

# 2. 插入元素
heapq.heappush(nums, 0)

# 3. 弹出最小值
min_val = heapq.heappop(nums)
print(f"最小值: {min_val}") # 输出 0

# 4. 查看堆顶 (不弹出)
print(f"当前堆顶: {nums[0]}")
```
注意：如果要实现最大堆，可以将所有数值取负存储，弹出时再取反